# Floyd-warshall algorithm

#### 플로이드 와샬 알고리즘

플로이드 와샬은 반복문을 3번 돌려서 최단경로를 얻을 수 있는 알고리즘입니다.

연산량은 O(|V|^3)이라는 연산량을 가지고, 컴퓨터가 1초에 처리하는 연산량이 1억 정도라 할 때,

정점의 수가 1000개 이상이라면? 즉, n = 1000이라면 1초 이상의 연산 시간이 걸릴 수 있습니다.

네비게이션에서 목적지까지의 최소비용을 출력하려하는데, 1초 이후에 값이 나오면 빠른 한국인의 특성상 뭔가 불편할 것입니다.

각설하고! 플로이드 와샬 알고리즘을 구현한 코드는 다음과 같습니다.

```c
#include <cstdio>    
    
int adj[20][20], INF = 1e4;    
    
int main()    
{    
  int n, m;    
  scanf("%d%d", &n, &m);    
    
  while(m--) {    
    int a, b, w;    
    scanf("%d%d%d", &a, &b, &w);    
    adj[a][b] = adj[b][a] = w;    
  }    
  
  //경로에 값이 없으면 무한으로 설정
  for(int i=1; i<=n; i++)    
    for(int j=1; j<=n; j++)    
      adj[i][j] = adj[i][j]?adj[i][j]:INF;    
  
  //플로이드 와샬 알고리즘 구현
  for(int i=1; i<=n; i++) {    
    for(int j=1; j<=n; j++) {    
      for(int k=1; k<=n; k++) {    
        if(adj[j][k] > adj[j][i] + adj[i][k]) {    
          adj[j][k] = adj[j][i] + adj[i][k];    
        }    
      }    
    }    
  }    
    
  printf(adj[1][n] != INF ? "%d" : "-1", adj[1][n]);    
    
  return 0;    
}  
```
위 코드를 보다보면, 플로이드 와샬 알고리즘을 구현하기 전에 값이 저장되지 않은 부분을 무한으로 처리해 준 부분을 볼 수 있습니다.

이렇게 해준 이유는 이후에 플로이드 와샬 알고리즘을 사용하면서 경로의 최솟값으로 계속 갱신을 해 주어야 하는데.. 0이면 갱신이 불가능하기 때문입니다.


원리는 간단합니다. j -> k로 가는 경로보다 j -> i -> k로 가는 경로의 비용이 더 작으면 값을 갱신해 줍니다.

최종적으로 배열에 저장되는 것은 제일 첫번째 인덱스. 즉, G[n][1]번째에 정점1부터 정점n까지의 최소비용이 저장되게 됩니다.

#### 플로이드 와샬 알고리즘 최단 경로 역추적

쉽게 말하자면 네비게이션에 출발과 도착을 찍었을 때, 비용만 나오고 경로가 나오지 않으면 얼마나 당황스러울까요? 그래서 추가적으로 최단경로를 출력하는 알고리즘에 대해 알아보겠습니다.

최단경로를 구하는 방법은 크게 4가지의 부분으로 나뉩니다.

- 1.시작정점 처리


시작정점을 처리해 주는 이유는 단순히 어디서 시작하는가?에 대한 정보를 넣기 위함입니다. 추후에 재귀함수로 최단경로를 추적할 때, 시작 역할을 해 줍니다.

- 2.경로 저장


가능한 모든 경로를 저장합니다. 플로이드 와샬을 구현할 때에는 j와 k가 연결되었다는 것을 인접행렬을 이용해 adj[j][k] = 가중치의 형식으로 저장하는데, 이를 이용해서 j -> k로 가는 경로에 i를 거친다를 path[j][k] = i 의 형태로 저장해 줍니다.


- 3.경로 역추적


시작점과 그 다음점을 가지고 재귀함수를 구현해 경로를 찾습니다.
만약 from -> to로 가면서 거친 정점을 prev에 저장해 놓은 다음에, 시작점과 prev가 같다면? 이것은 최단경로라는 것을 의미합니다.

예를 들어, 1 -> 2 -> 3 이라는 관계가 존재한다고 해 봅시다. 1 -> 3으로 가는 길에 2를 통해서 가는 길이 더 빠르다면? 이것은 최단경로가 아니지만, 1 -> 3 사이에 거치는 정점이 존재하지 않는다면 이것은 최단경로가 됩니다.

최단경로가 맞다면? 배열에 저장하고 끝내고, 아니라면? 재귀를 돌려주면 됩니다.
1 -> 2 -> 3 의 관계에서 1 -> 3이 최단경로가 아니라면? 1 -> 2 또는 2 -> 3이 최단경로일 것입니다.


- 4.경로 출력


굳이 이걸 포함시켜야 하나 하는 생각은 들었지만... 최단경로를 모두 구했다면 경로를 출력해 줍니다.
하나 주의해야 할 것이 있다면, 역추적을 완료했을 때 배열에는 도착정점이 들어있지 않습니다. 이것을 포함시켜 주어야 합니다.




참고자료 :
<https://koosaga.com/2>,
<https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm>,
<https://eazymean.tistory.com/384>
